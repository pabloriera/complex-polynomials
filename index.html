<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>complex polynomials</title>

  <meta name="description"  content="A library displaying GLSL fragment shaders as a website background" />
  <meta name="keywords"     content="OpenGL, GLSL, WebGL, shader, shaders, fragment shader, web, web development, background, animation" />
  <meta name="author"       content="Kazik Pogoda" />

  <meta property="og:title"         content="complex polynomials" />
  <meta property="og:type"          content="website" />
  <meta property="og:url"           content="https://xemantic.github.io/shader-web-background/" />
  <meta property="og:image"         content="https://xemantic.github.io/shader-web-background/media/shader-web-backgroung.jpg" />
  <meta property="og:image:type"    content="image/jpeg" />
  <meta property="og:image:width"   content="1200" />
  <meta property="og:image:height"  content="630" />
  <meta property="og:image:alt"     content="complex polynomials logo" />
  <meta property="og:description"   content="A library displaying GLSL fragment shaders as a website background" />
  <meta property="og:locale"        content="en_US" />
  <meta property="fb:app_id"        content="3733288006778720" />

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <link rel="shortcut icon" href="media/icons/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="media/icons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="media/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="media/icons/favicon-16x16.png">
  <link rel="manifest" href="media/icons/site.webmanifest">
  <link rel="mask-icon" href="media/icons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-config" content="media/icons/browserconfig.xml">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <script>
    /*
    @licstart  The following is the entire license notice for the
    JavaScript and GLSL code in this page.

    Copyright (C) 2020  Kazimierz Pogoda

    The JavaScript and GLSL code in this page is free software: you can
    redistribute it and/or modify it under the terms of the GNU
    General Public License (GNU GPL) as published by the Free Software
    Foundation, either version 3 of the License, or (at your option)
    any later version.  The code is distributed WITHOUT ANY WARRANTY;
    without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

    As additional permission under GNU GPL version 3 section 7, you
    may distribute non-source (e.g., minimized or compacted) forms of
    that code without the copy of the GNU GPL normally required by
    section 4, provided you include this license notice and a URL
    through which recipients can access the Corresponding Source.


    @licend  The above is the entire license notice
    for the JavaScript and GLSL code in this page.
    */
  </script>
  <script>
// -- https://xemantic.github.io/shader-web-background/
const shaderWebBackground={};(()=>{'use strict';const t=(a,b)=>{b.initHalfFloatRGBATexture(b.width,b.height);a.texParameteri(a.TEXTURE_2D,
a.TEXTURE_MIN_FILTER,a.LINEAR);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,
a.LINEAR);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE);a.texParameteri(a.TEXTURE_2D,
a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE)},x=(a,b)=>{console.warn("shader-web-background cannot shade, adding fallback CSS classes");
document.documentElement.classList.add("shader-web-background-fallback");b.classList.add("shader-web-background-fallback");
if(a instanceof shaderWebBackground.GlError)console.warn("Not sufficient WebGL support:",
a);else throw a;};
function y(a,b){if(!a)throw new shaderWebBackground.ConfigError(b);}
function z(a){y(a instanceof HTMLCanvasElement,"config.canvas must be instance of canvas");
return a}
function A(){const a=document.createElement("canvas"),b=a.style;a.id="shader-web-background";b.width=
"100vw";b.height="100vh";b.position="fixed";b.top="0";b.left="0";b.zIndex=-9999;return a}
function B(a,b,c){y(a instanceof HTMLScriptElement&&a.type===b,'Shader source element of id "'+
c+'" should be of type: <script type="'+(b+'" id="'+c+'">'))}
function D(a){const b=document.getElementById(a);y(b,'Missing shader source: <script type="x-shader/x-fragment" id="'+
(a+'">'));B(b,"x-shader/x-fragment",a);return b.text}
function E(a){a+="Vertex";const b=document.getElementById(a);return b?(B(b,"x-shader/x-vertex",
a),b.text):"attribute vec2 V;void main(){gl_Position=vec4(V,0,1);}"}
function F(a,b){"loading"!==document.readyState?b():window.addEventListener(a,b)}
class G{constructor(a,b,c,d){this.g=c;const l=a.gl;this.h=()=>{for(const f of d)f.u(l,
f.location,b)};this.i=()=>{var f=c.v,h=a.gl;h.bindBuffer(h.ARRAY_BUFFER,a.j);h.enableVertexAttribArray(f);
h.vertexAttribPointer(f,2,h.FLOAT,!1,0,0);h.drawArrays(h.TRIANGLE_STRIP,0,4);h.disableVertexAttribArray(f);
h.bindBuffer(h.ARRAY_BUFFER,null);f=a.gl;for(h=0;h<a.g;h++)f.activeTexture(f.TEXTURE0+
h),f.bindTexture(f.TEXTURE_2D,null);a.g=0}}}
function H(a){var b={antialias:!1,depth:!1,alpha:!1};try{return new I(a,b)}catch(c){throw new shaderWebBackground.GlError(c.message);
}}
function J(a,b,c,d,l,f){function h(e,m,n){try{{var k=p;const q=k.gl,P=K(k,e,q.VERTEX_SHADER,m),
Q=K(k,e,q.FRAGMENT_SHADER,n),v=q.createProgram();q.attachShader(v,P);q.attachShader(v,
Q);q.linkProgram(v);var r=v}return r}catch(q){throw new shaderWebBackground.ConfigError(q.message);
}}const p=H(a),w=[],g={gl:p.gl,canvas:a,width:0,height:0,cssPixelRatio:0,cssWidth:0,
cssHeight:0,isOverShader:(e,m)=>{const n=a.getBoundingClientRect();return e>=n.left&&
e<=n.right&&m>=n.top&&m<=n.bottom},toShaderX:e=>(e-a.getBoundingClientRect().left)*
g.cssPixelRatio+.5,toShaderY:e=>a.height-(e-a.getBoundingClientRect().top)*g.cssPixelRatio-
.5,s:()=>g.cssWidth!==a.clientWidth||g.cssHeight!==a.clientHeight?(g.resize(),!0):
!1,resize:()=>{const e=window.devicePixelRatio||1,m=a.clientWidth,n=a.clientHeight,
k=Math.floor(m*e),r=Math.floor(n*e);a.width=k;a.height=r;g.width=k;g.height=r;g.cssPixelRatio=
e;g.cssWidth=m;g.cssHeight=n;p.gl.viewport(0,0,p.canvas.width,p.canvas.height);for(const q of w)q.g.l(k,
r)},texture:(e,m)=>{{var n=p;const k=n.gl;m=m instanceof L?m.g:m;k.activeTexture(k.TEXTURE0+
n.g);k.bindTexture(k.TEXTURE_2D,m);k.uniform1i(e,n.g++)}},buffers:{},initHalfFloatRGBATexture:(e,
m)=>{p.h.g(e,m)}},R=Object.keys(b).length-1;let S=0;for(const e in b){if(S++<R){const k=
b[e].texture||t;g.buffers[e]=M(p,()=>{k(p.gl,g)})}const m=N(p,h(e,E(e),D(e)),g.buffers[e]),
n=b[e].uniforms||{};var u=Object.keys(n);for(const k of m.m)y(n[k.name],'No configuration for uniform "'+
k.name+'" defined in shader "'+e+'"'),u=u.filter(r=>r!==k.name);0!==u.length&&console.warn('Extra uniforms configured for shader "'+
e+'", which are not present in the shader code - might have been removed by GLSL compiler if not used: '+
u.join(", "));u=m.m.map(k=>({location:k.location,u:n[k.name]}));w.push(new G(p,g,
m,u))}const C=()=>{g.s()&&d&&d(g.width,g.height,g);l&&l(g);for(const e of w)e.g.i(e.h,
e.i);f&&f(g);requestAnimationFrame(C)};F("load",()=>{g.resize();c&&c(g);d&&d(g.width,
g.height,g);requestAnimationFrame(C)});return g}
shaderWebBackground.Error=class extends Error{constructor(a){super(a);this.name="shaderWebBackground.Error"}};
shaderWebBackground.ConfigError=class extends shaderWebBackground.Error{constructor(a){super(a);
this.name="shaderWebBackground.ConfigError"}};
shaderWebBackground.GlError=class extends shaderWebBackground.Error{constructor(a){super(a);this.name=
"shaderWebBackground.GlError"}};
shaderWebBackground.shade=function(a){y(a,"Missing config argument");const b=a.canvas?
z(a.canvas):A();y(a.shaders,"No shaders specified in config");try{const c=J(b,a.shaders,
a.onInit,a.onResize,a.onBeforeFrame,a.onAfterFrame);a.canvas||F("DOMContentLoaded",
()=>{document.body.appendChild(b)});return c}catch(c){(a.onError||x)(c,b)}};const O=[-1,1,1,1,-1,-1,1,-1];
function T(a,b){return a.j(a.gl.getExtension(b),b+" extension is not supported")}
class U{constructor(a,b){this.gl=a;this.j=b}g(){}}
class V extends U{constructor(a,b){super(a,b);this.h=T(this,"OES_texture_half_float");
T(this,"OES_texture_half_float_linear")}g(a,b){const c=this.gl;c.texImage2D(c.TEXTURE_2D,
0,c.RGBA,a,b,0,c.RGBA,this.h.HALF_FLOAT_OES,null)}}
class W extends U{constructor(a,b){super(a,b);T(this,"EXT_color_buffer_float");this.gl.getExtension("OES_texture_float_linear")}g(a,
b){const c=this.gl;c.texImage2D(c.TEXTURE_2D,0,c.RGBA16F,a,b,0,c.RGBA,c.HALF_FLOAT,
null)}}
function X(a){a=a.split(/\r?\n/);const b=a.length.toString().length;var c=[];a.forEach((d,
l)=>{l=(l+1).toString();l=l.length>=b?l:" ".repeat(b-l.length)+l;c.push(l+": "+d+
"\n")});return c.join("")}function M(a,b){return new L(a.gl,()=>{b(a.gl)})}
function N(a,b,c){const d=a.gl;a=[];const l=d.getProgramParameter(b,d.ACTIVE_UNIFORMS);
for(let f=0;f<l;f++){const h=d.getActiveUniform(b,f);a.push({name:h.name,location:d.getUniformLocation(b,
h.name)})}return{v:d.getAttribLocation(b,"V"),m:a,l:c?(f,h)=>c.l(f,h):()=>{},i:(f,
h)=>{d.useProgram(b);f();c?(f=c.g,c.g=c.h,c.h=f,c.i(h)):h()}}}
function K(a,b,c,d){a=a.gl;c=a.createShader(c);a.shaderSource(c,d);a.compileShader(c);
if(!a.getShaderParameter(c,a.COMPILE_STATUS)){const l=String(a.getShaderInfoLog(c));
a.deleteShader(c);b="Cannot compile shader - "+b+": "+l;console.log(b);console.log(X(d));
throw Error(b);}return c}
class I{constructor(a,b){this.canvas=a;const c=(l,f)=>{if(!l)throw Error(f);return l};
let d=a.getContext("webgl2",b);if(d)this.h=new W(d,c);else if(d=a.getContext("webgl",
b))this.h=new V(d,c);c(d,"webgl context not supported on supplied canvas element: "+
a);this.gl=d;a=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,a);d.bufferData(d.ARRAY_BUFFER,
new Float32Array(O),d.STATIC_DRAW);d.bindBuffer(d.ARRAY_BUFFER,null);this.j=a;this.buffers=
{};this.g=0}}
function Y(a){const b=a.gl,c=b.createTexture();b.bindTexture(b.TEXTURE_2D,c);a.o(b);
b.bindTexture(b.TEXTURE_2D,null);return c}
class L{constructor(a,b){this.j=a.createFramebuffer();this.gl=a;this.o=b;this.g=this.h=
null}l(){this.h&&this.gl.deleteTexture(this.h);this.g&&this.gl.deleteTexture(this.g);
this.h=Y(this);this.g=Y(this)}i(a){const b=this.gl;b.bindFramebuffer(b.FRAMEBUFFER,
this.j);b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,this.g,
0);a();b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,null,
0);b.bindFramebuffer(b.FRAMEBUFFER,null)}};})()
//# sourceMappingURL=dist/shader-web-background.min.js.map
  </script>
  <script>
    // spectral_zucconi6 by Alan Zucconi rewritten from GLSL to JS by Kazik Pogoda
    // GLSL: https://www.shadertoy.com/view/ls2Bz1

    const ONE_IN_3D = [1, 1, 1];
    const c1 = [3.54585104, 2.93225262, 2.41593945];
    const x1 = [0.69549072, 0.49228336, 0.27699880];
    const y1 = [0.02312639, 0.15225084, 0.52607955];
    const c2 = [3.90307140, 3.21182957, 3.96587128];
    const x2 = [0.11748627, 0.86755042, 0.66077860];
    const y2 = [0.84897130, 0.88445281, 0.73949448];
    const saturate = (x) => Math.min(Math.max(x, 0), 1);
    const to3d = (x) => [x, x, x];
    const add3d = (x, y) => [x[0] + y[0], x[1] + y[1], x[2] + y[2]];
    const subtract3d = (x, y) => [x[0] - y[0], x[1] - y[1], x[2] - y[2]];
    const multiply3d = (x, y) => [x[0] * y[0], x[1] * y[1], x[2] * y[2]];
    const pow23d = (x) => multiply3d(x, x);
    const saturate3d = (x) => [saturate(x[0]), saturate(x[1]), saturate(x[2])];
    const bump3y = (x, yoffset) => saturate3d(subtract3d(subtract3d(ONE_IN_3D, pow23d(x)), yoffset));
    const spectral_zucconi6 = (x) => add3d(bump3y(multiply3d(c1, subtract3d(to3d(x), x1)), y1), bump3y(multiply3d(c2, subtract3d(to3d(x), x2)), y2));
  </script>
  <script type="x-shader/x-fragment" id="feedback">
#extension GL_OES_standard_derivatives : enable
precision highp float;

#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
//#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))
#define cx_modulus(a) length(a)
#define cx_conj(a) vec2(a.x, -a.y)
#define cx_arg(a) atan(a.y, a.x)
#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))
#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))
#define PI 3.1415926538


// Hyperboloc functions by toneburst from 
// https://machinesdontcare.wordpress.com/2008/03/10/glsl-cosh-sinh-tanh/
// These are missing in GLSL 1.10 and 1.20, uncomment if you need them 

vec2 cx_div(vec2 a, vec2 b){
    return vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)));
   }

/// COSH Function (Hyperbolic Cosine)
float cosh(float val)
{
    float tmp = exp(val);
    float cosH = (tmp + 1.0 / tmp) / 2.0;
    return cosH;
}
 
// TANH Function (Hyperbolic Tangent)
float tanh(float val)
{
    float tmp = exp(val);
    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);
    return tanH;
}
 
// SINH Function (Hyperbolic Sine)
float sinh(float val)
{
    float tmp = exp(val);
    float sinH = (tmp - 1.0 / tmp) / 2.0;
    return sinH;
}   


// Complex Number math by julesb
// https://github.com/julesb/glsl-util
// Additions by Johan Karlsson (DonKarlssonSan)



vec2 cx_sqrt(vec2 a) {
    float r = length(a);
    float rpart = sqrt(0.5*(r+a.x));
    float ipart = sqrt(0.5*(r-a.x));
    if (a.y < 0.0) ipart = -ipart;
    return vec2(rpart,ipart);
}

vec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }

vec2 cx_log(vec2 a) {
    float rpart = sqrt((a.x*a.x)+(a.y*a.y));
    float ipart = atan(a.y,a.x);
    if (ipart > PI) ipart=ipart-(2.0*PI);
    return vec2(log(rpart),ipart);
}

vec2 cx_mobius(vec2 a) {
    vec2 c1 = a - vec2(1.0,0.0);
    vec2 c2 = a + vec2(1.0,0.0);
    return cx_div(c1, c2);
}

vec2 cx_z_plus_one_over_z(vec2 a) {
    return a + cx_div(vec2(1.0,0.0), a);
}

vec2 cx_z_squared_plus_c(vec2 z, vec2 c) {
    return cx_mul(z, z) + c;
}

vec2 cx_sin_of_one_over_z(vec2 z) {
    return cx_sin(cx_div(vec2(1.0,0.0), z));
}

////////////////////////////////////////////////////////////
// end Complex Number math by julesb
////////////////////////////////////////////////////////////

// My own additions to complex number math
#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)
#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)
#define cx_abs(a) length(a)
vec2 cx_to_polar(vec2 a) {
    float phi = atan(a.y / a.x);
    float r = length(a);
    return vec2(r, phi); 
}
    
// Complex power
// Let z = r(cos θ + i sin θ)
// Then z^n = r^n (cos nθ + i sin nθ)
vec2 cx_pow(vec2 a, float n) {
    float angle = atan(a.y, a.x);
    float r = length(a);
    float real = pow(r, n) * cos(n*angle);
    float im = pow(r, n) * sin(n*angle);
    return vec2(real, im);
}
precision highp float;

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main( void ) {

	vec2 position = ( gl_FragCoord.xy / resolution.x ) - vec2(0.5,0.25);
	vec2 m = mouse.xy/vec2(1.0,resolution.x/resolution.y)  - vec2(0.5,0.25);

	float color = 0.0;
	
	vec2 z = vec2(position.x,position.y);
	
	vec2 z0 = vec2(cos(time*0.1),sin(time*0.1))*0.01 + vec2(cos(time*0.2),sin(time*0.2))*0.07;
	vec2 z1 = vec2(cos(time*0.3),sin(time*0.3))*0.03 + vec2(cos(time*0.4),sin(time*0.4))*0.03;
	vec2 z2 = vec2(cos(time*0.5),sin(time*0.5))*0.05 + vec2(cos(time*0.6),sin(time*0.6))*0.05;
	vec2 z3 = vec2(cos(time*0.7),sin(time*0.7))*0.07 + vec2(cos(time*0.8),sin(time*0.8))*0.01;
	vec2 z4 = vec2(cos(time*0.15),sin(time*0.15))*0.015 + vec2(cos(time*0.25),sin(time*0.25))*0.075;
	vec2 z5 = vec2(cos(time*0.35),sin(time*0.35))*0.035 + vec2(cos(time*0.45),sin(time*0.45))*0.035;
	vec2 z6 = vec2(cos(time*0.55),sin(time*0.55))*0.055 + vec2(cos(time*0.65),sin(time*0.65))*0.055;
	vec2 z7 = vec2(cos(time*0.75),sin(time*0.75))*0.075 + vec2(cos(time*0.85),sin(time*0.85))*0.015;
	
	vec2 w = cx_div(cx_mul(cx_mul(cx_mul((z-z0),(z-z1)),(z-z2)),(z-z3)  ), cx_mul(cx_mul(cx_mul((z-z4),(z-z5)),(z-z6)),(z-z7)  ));
//	vec2 w = z-z0;
	
	vec2 rot = vec2(cos(time),sin(time))*0.0+1.0;
	color = (cx_arg(cx_mul(w,rot))+PI)/2.0/PI;
	//color *= clamp( cx_abs(w)*0.1, 0.0, 1.0);
	
	gl_FragColor = vec4(  color, color, color,  1.0 );

}
  </script>

  <!--
    The "image" shader will just copy the "feedback" output to the canvas.
   -->
  <script type="x-shader/x-fragment" id="image">
    precision highp float;

    uniform vec2 iResolution;
    uniform sampler2D iChannel0;

    void main(){
      gl_FragColor = texture2D(iChannel0, gl_FragCoord.xy / iResolution);
    }
  </script>
  <script>
    var time;

    var minDimension;
    var screenRatioHalfX;
    var screenRatioHalfY;

    var mouseX;
    var mouseY;

    var stMouseX;
    var stMouseY;

    var tiltLR = 0;
    var tiltFB = 0;
    var tiltFBDelta = null;

    var feedbackShiftVectorX;
    var feedbackShiftVectorY;

    var oldScrollY;

    var drawCenterX;
    var drawCenterY;

    const feedbackMouseShiftFactor = .003;
    const feedbackTiltShiftFactor = .0002;
    const backgroundParallaxScrollingFactor = .5;
    const blob1ColorPulseSpeed = .04;
    const blob2ColorPulseSpeed = .04;
    const blob2ColorPulseShift = .5;
    const drawCenterShiftDownScale = .99;

    var blob1Color;
    var blob2Color;

    const loadScript = (src) => new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = src;
      script.type = "text/javascript";
      script.async = true;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });

    const onWindowLoad = () => new Promise((resolve) => {
      window.addEventListener("load", resolve);
    });

    function goFullScreen(canvas, noSleep) {
      screenfull.on("change", () => {
        if (!screenfull.isFullscreen) {
          noSleep.disable();
        }
      });
      screenfull
        .request(canvas)
        .then(() => noSleep.enable());
    }

    function newButton(label, action) {
      const button = document.createElement("button");
      button.textContent = label;
      button.addEventListener("click", action);
      return button;
    }

    function addControl(control) {
      document
        .getElementById("controls")
        .appendChild(control);
    }

    function maybeAddFullScreenAction() {
      if (screenfull.isEnabled) {
        const canvas = document.getElementById("shader-web-background");
        const noSleep = new NoSleep();
        addControl(
          newButton(
            "Go Full Screen",
            () => goFullScreen(canvas, noSleep)
          )
        );
      }
    }

    function handleDeviceOrientationChange(event) {
      if (event.beta) {
        if (tiltFBDelta) {
          tiltFB = event.beta - tiltFBDelta;
        } else {  // first reading or calibration
          tiltFBDelta = event.beta;
          tiltFB = 0;
        }
      }
      if (event.gamma) {
        tiltLR = event.gamma;
      }
    }

    const deviceOrientationEvent = "deviceorientation";

    function trackDeviceOrientation() {
      window.addEventListener(deviceOrientationEvent, handleDeviceOrientationChange, false);
    }

    function untrackDeviceOrientation() {
      window.removeEventListener(deviceOrientationEvent, handleDeviceOrientationChange, false);
    }

    function calibrateDeviceOrientation() {
      tiltFBDelta = null;
    }

    function initDeviceOrientation() {
      if (DeviceOrientationEvent.requestPermission) {
        DeviceOrientationEvent.requestPermission()
          .then(response => {
            if (response == "granted") {
              tiltFBDelta = null;
              untrackDeviceOrientation(); // just in case it is subsequent attempt
              trackDeviceOrientation();
            }
          })
          .catch(console.error);
      } else {
        trackDeviceOrientation();
        tiltFBDelta = null;
      }
    }

    function maybeAddCalibrateDeviceOrientationAction() {
      if (window.DeviceOrientationEvent) {
       addControl(
          newButton(
            "Calibrate Device Orientation",
            () => initDeviceOrientation()
          )
        );
      }
    }

    function maybeAddActions() {
      maybeAddCalibrateDeviceOrientationAction();
      maybeAddFullScreenAction();
    }

    if (window.DeviceOrientationEvent) {
      if (!DeviceOrientationEvent.requestPermission) {
        trackDeviceOrientation();
      }
    }

    document.addEventListener("mousemove", (event) => {
       mouseX = event.clientX;
       mouseY = event.clientY;
    });

    onWindowLoad()
      .then(() => Promise.all([
        loadScript("https://unpkg.com/screenfull/dist/screenfull.js"),
        loadScript("https://unpkg.com/nosleep.js/dist/NoSleep.min.js")
      ]))
      .then(maybeAddActions);

    shaderWebBackground.shade({
      onInit: (ctx) => {
        mouseX = ctx.cssWidth / 2.;
        mouseY = ctx.cssHeight / 2.;
        oldScrollY = window.scrollY;
        drawCenterX = 0;
        drawCenterY = 0;
      },
      onResize: (width, height) => {
        minDimension = Math.min(width, height);
        if (width >= height) {
          screenRatioHalfX = height / width * .5;
          screenRatioHalfY = .5;
        } else {
          screenRatioHalfX = .5;
          screenRatioHalfY = width / height * .5;
        }
      },
      onBeforeFrame: (ctx) => {
        stMouseX = (2 * ctx.toShaderX(mouseX) - ctx.width) / minDimension;
        stMouseY = (2 * ctx.toShaderY(mouseY) - ctx.height) / minDimension;
        time = performance.now() / 1000;
        const scrollY = window.scrollY;
        const scrollYDelta = scrollY - oldScrollY;
        if (scrollYDelta === 0) {
          feedbackShiftVectorY = 0;
        } else {
          feedbackShiftVectorY =
            scrollYDelta / minDimension
            * 2 * ctx.cssPixelRatio
            * backgroundParallaxScrollingFactor;
          drawCenterY += feedbackShiftVectorY;
        }
        oldScrollY = scrollY;
        if (tiltFBDelta) { // we have device orientation readings, better than mouse
          feedbackShiftVectorX = tiltLR * feedbackTiltShiftFactor;
          feedbackShiftVectorY += tiltFB * -feedbackTiltShiftFactor;
        } else {
          feedbackShiftVectorX = stMouseX * feedbackMouseShiftFactor;
          feedbackShiftVectorY += stMouseY * feedbackMouseShiftFactor;
        }
        blob1Color = spectral_zucconi6((time * blob1ColorPulseSpeed) % 1);
        blob2Color = spectral_zucconi6((time * blob2ColorPulseSpeed + blob2ColorPulseShift) % 1);
      },
      shaders: {
        feedback: {
          uniforms: {
            iResolution:               (gl, loc, ctx) => gl.uniform2f(loc, ctx.width, ctx.height),
            iMinDimension:             (gl, loc) => gl.uniform1f(loc, minDimension),
            iScreenRatioHalf:          (gl, loc) => gl.uniform2f(loc, screenRatioHalfX, screenRatioHalfY),
            iFeedbackZoomCenter:       (gl, loc) => gl.uniform2f(loc, 0, 0),
            iFeedbackZoomRate:         (gl, loc) => gl.uniform1f(loc, .001),
            iFeedbackShiftVector:      (gl, loc) => gl.uniform2f(loc, feedbackShiftVectorX, feedbackShiftVectorY),
            iFeedbackFadeRate:         (gl, loc) => gl.uniform1f(loc, .999),
            iFeedbackColorShiftZoom:   (gl, loc) => gl.uniform1f(loc, .2),
            iFeedbackColorShiftImpact: (gl, loc) => gl.uniform1f(loc, .004),
            iDrawCenter:               (gl, loc) => gl.uniform2f(loc, drawCenterX, drawCenterY),
            iDrawIntensity:            (gl, loc) => gl.uniform1f(loc, .35),
            iBlobEdgeSmoothing:        (gl, loc) => gl.uniform1f(loc, .04),
            iBlob1Radius:              (gl, loc) => gl.uniform1f(loc, .3),
            iBlob1PowFactor:           (gl, loc) => gl.uniform1f(loc, 40.),
            iBlob1Color:               (gl, loc) => gl.uniform3f(loc, blob1Color[0], blob1Color[1], blob1Color[2]),
            iBlob2Radius:              (gl, loc) => gl.uniform1f(loc, .4),
            iBlob2PowFactor:           (gl, loc) => gl.uniform1f(loc, 40.),
            iBlob2Color:               (gl, loc) => gl.uniform3f(loc, blob2Color[0], blob2Color[1], blob2Color[2]),
            iColorShiftOfRadius:       (gl, loc) => gl.uniform1f(loc, .5),
            iChannel0:                 (gl, loc, ctx) => ctx.texture(loc, ctx.buffers.feedback)
          }
        },
        image: {
          uniforms: {
            iResolution: (gl, loc, ctx) => gl.uniform2f(loc, ctx.width, ctx.height),
            iChannel0: (gl, loc, ctx) => ctx.texture(loc, ctx.buffers.feedback),
          }
        }
      },
      onAfterFrame: () => {
        drawCenterY *= drawCenterShiftDownScale;
      },
      onError: (error, canvas) => {
        document.documentElement.classList.add("fallback-background");
        if (error instanceof shaderWebBackground.GlError) {
          console.log("Could not shade, adding fallback CSS classes:", error);
          // in regular web design we would just silently switch to fallback style
          window.alert(
            "The shader-web-background does not support your device/browser, therefore "
              + "you cannot experience what is described here, try with another device");
        } else {
          throw error;
        }
      }
    });
  </script>
  <style>
    html {
      box-sizing: border-box;
      background: black;
      font-size: calc(16px + .8vw);
      font-family: sans-serif;
      scroll-behavior: smooth;
      line-height: 2em;
    }
    *, *:before, *:after {
      box-sizing: inherit;
    }
    body {
      color: white;
      overflow-x: hidden;
    }
    body, h1, h2, p, ul, blockquote {
      margin: 0;
      padding: 0;
    }
    p, ul {
      margin-top: .618rem;
      margin-bottom: .618rem;
    }
    h2 {
      font-size: 1.5rem;
      text-align: center;
      margin-top: 1.618rem;
      margin-bottom: 1.618rem;
      line-height: 2.15em;
    }
    section {
      background: rgba(0, 0, 0, .3);
      margin-top: 0rem;
      padding-top: .618rem;
      padding-bottom: 2rem;
    }
    section, footer {
      margin-bottom: 6.472rem;
    }
    header {
      height: 100vh;
      opacity: 1;
      transition: opacity 2s;
    }
    header h1 {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    header, section, footer {
      padding-left:  calc(-20px + 10vw);
      padding-right: calc(-20px + 10vw);
    }
    a {
      text-decoration: none;
      color: white;
      background: rgba(255, 0, 255, .2);
      transition: color 2s, background 2s;
      padding: .31rem .13rem;
      margin: -.31rem -.13rem;
      border-radius: .47rem;
    }
    a:hover {
      color: black;
      background: rgba(0, 255, 0, .2);
    }
    ul {
      margin-left: 1.1rem;
    }
    li {
      margin-bottom: .618rem;
    }
    footer {
      font-size: .8rem;
      text-align: center;
      font-style: italic;
      line-height: 2.15em;
    }
    .scroll-to-intro {
      margin-top: -6vh;
      height: 6vh;
      position: relative;
    }
    .scroll-to-intro a {
      background: radial-gradient(farthest-side at bottom,
        rgba(255, 255, 255, .6),
        rgba(255, 255, 255, .0)
      );
      display: block;
      height: 100%;
      animation: 5s blink linear infinite;
      animation-fill-mode: both;
      animation-delay: 10s;
    }
    button {
      background: rgba(255, 0, 255, .6);
      margin: .618em;
      border: none;
      color: white;
      padding: .618em;
      text-align: center;
      font-size: inherit;
      transition: color 1.6s, background 1.6s;
      border-radius: .47rem;
      cursor: pointer;
    }
    button:hover {
      background: rgba(0, 255, 0, .6);
      color: black;
    }
    a.tea {
      background: transparent;
      margin: 0;
      padding: 0;
      transition: filter 2s;
    }
    a.tea:hover {
      filter: invert(1);
    }
    a.tea > img {
      height: 1.8rem;
      vertical-align: middle;
    }
    .logo {
      height: 100%;
      pointer-events: none;
      animation: fade-in 20s;
      animation-fill-mode: both;
      animation-delay: 5s;
    }
    .logo g {
      fill: #ffffff;
      opacity: 1;
    }
    .logo #reds {
      animation: fade-to-red linear 15s infinite;
      animation-fill-mode: forwards;
      animation-delay: 20s;
    }
    .logo #greens {
      animation: fade-to-green linear 15s infinite;
      animation-fill-mode: forwards;
      animation-delay: 21s;
    }
    .logo #blues {
      animation: fade-to-blue linear 15s infinite;
      animation-fill-mode: forwards;
      animation-delay: 22s;
    }
    #controls {
      text-align: center;
    }
    .fallback-background {
      background: black url("media/fallback.jpg");
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
    }
    @keyframes blink {
      0%   { opacity: 0; }
      50%  { opacity: 0; }
      75%  { opacity: 1; }
      100% { opacity: 0; }
    }
    @keyframes fade-in {
      0%   { opacity: 0; }
      100% { opacity: .5; }
    }
    @keyframes fade-to-red {
      0%,20%,100% { fill: #ffffff; }
      7%,10% { fill: #ff0000; }
    }
    @keyframes fade-to-green {
      0%,20%,100% { fill: #ffffff; }
      7%,10% { fill: #00ff00; }
    }
    @keyframes fade-to-blue {
      0%,20%,100% { fill: #ffffff; }
      7%,10% { fill: #0000ff; }
    }
  </style>
</head>
<body>

</body>
</html>
